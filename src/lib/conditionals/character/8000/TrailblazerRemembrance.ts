import { AbilityType, BUFF_PRIORITY_MEMO, BUFF_PRIORITY_SELF } from 'lib/conditionals/conditionalConstants'
import { AbilityEidolon, Conditionals, ContentDefinition } from 'lib/conditionals/conditionalUtils'
import { ConditionalActivation, ConditionalType, Stats } from 'lib/constants/constants'
import { conditionalWgslWrapper } from 'lib/gpu/conditionals/dynamicConditionals'
import { wgslFalse } from 'lib/gpu/injection/wgslUtils'
import { Source } from 'lib/optimization/buffSource'
import { ComputedStatsArray, Key } from 'lib/optimization/computedStatsArray'
import { TsUtils } from 'lib/utils/TsUtils'

import { Eidolon } from 'types/character'
import { CharacterConditionalsController } from 'types/conditionals'
import { OptimizerAction, OptimizerContext } from 'types/optimizer'

/*

Almighty Companion

Talent

Memosprite Mem has an initial SPD of 130 and Max HP equal to 80% of Trailblazer's Max HP plus 640. For every 10 Energy regenerated by all allies in total, Mem gains 1% Charge.

Lv10

Baddies! Trouble!

Memosprite Skill+10

Deals 4 instance(s) of DMG, with each instance dealing Ice DMG equal to 36% of Mem's ATK to one random enemy. Finally, deals Ice DMG equal to 90% of Mem's ATK to all enemies.

 Single 5 | All 10

Lv6

Friends! Together!

Memosprite Talent

All allies' CRIT DMG increases by 12% of Mem's CRIT DMG plus 24%.
If the Charge has yet to reach 100%, Mem automatically uses "Baddies! Trouble!" during action. When the Charge reaches 100%, Mem immediately takes action, and can select one ally unit to use "Lemme! Help You!" in the next action.

Lv6

Go, Mem, Go!

Memosprite Talent

When Mem is summoned, immediately gains 50% Charge.

Lv6

No... Regrets

Memosprite Talent

When Mem disappears, advances Trailblazer's action by 25%.

Lv6

Lemme! Help You!

Memosprite Skill+10

Advances the action of one designated ally by 100% and grants them "Mem's Support," lasting for 3 turn(s).
For every 1 instance of DMG dealt by the target that has "Mem's Support," additionally deals 1 instance of True DMG equal to 28% of the original DMG.
When using this ability on this unit, cannot trigger the action advance effect.

True DMG
Non-Type DMG that is not affected by any effects. This DMG is not considered as using 1 attack.

Lv6

Leave It to Me!

Basic ATK+1+20

Deals Ice DMG equal to 100% of Trailblazer's ATK to one designated enemy.

 Single 10

Lv6

I Choose You!

Skill-1+30

Summons the memosprite Mem. If Mem is already on the field, restores Mem's HP by an amount equal to 60% of Mem's Max HP, and grants Mem 10% Charge.

Summon Memosprite
Summon the memosprite to the field. If the memosprite is already on the field, dispels all Crowd Control debuffs the memosprite is afflicted with.

Lv10

Together, Mem!

Ultimate160+5

Summons memosprite Mem. Grants Mem 40% Charge, then enables Mem to deal Ice DMG equal to 240% of Mem's ATK to all enemies.

 All 20

Lv10

Almighty Companion

Talent

Memosprite Mem has an initial SPD of 130 and Max HP equal to 80% of Trailblazer's Max HP plus 640. For every 10 Energy regenerated by all allies in total, Mem gains 1% Charge.

Lv10

Attack

Attacks an enemy, and when the battle starts, reduces their Toughness of the corresponding Type.

 Single 10


Memories Back as Echoes

Technique

After using Technique, creates a Special Dimension that lasts for 10 second(s). Enemies within the Special Dimension are placed in a Time Stop state, halting all their actions.
After entering battle against enemies afflicted with the Time Stop state, delays the action of all enemies by 50%, and then deals Ice DMG to all enemies equal to 100% of Trailblazer's ATK.
Only 1 Dimension Effect created by allies can exist at the same time.


I Choose You!

Skill-1+30

Lv10

Stat Boosts

 +37.3% CRIT DMG
 +14.0% ATK
 +14.0% HP

Rhapsode's Scepter

When the battle starts, Trailblazer's action advances by 30%. When Mem is first summoned, grants Mem 40% Charge.


Petite Parable

When using "Baddies! Trouble!," Mem immediately gains 5% Charge.


Magnets and Long Chains

When the Max Energy of the ally target that has "Mem's Support" exceeds 100, for every 10 excess Energy, additionally increases the multiplier of the True DMG dealt via "Mem's Support" by 2%, up to a max increase of 20%.

True DMG
Non-Type DMG that is not affected by any effects. This DMG is not considered as using 1 attack.



1 Narrator of the Present

Increases the CRIT Rate of the ally target with "Mem's Support" by 10%. When an ally target has "Mem's Support," its effect also takes effect on the target's memosprite/memomaster. This effect cannot stack.



2 Gleaner of the Past

When ally memosprites (aside from Mem) take action, Trailblazer regenerates 8 Energy. This effect can trigger a max of 1 time(s) per turn. The trigger count resets at the start of Trailblazer's turn.



3 Chanter of the Future

Skill Lv. +2, up to a maximum of Lv. 15.
Talent Lv. +2, up to a maximum of Lv. 15.
Memosprite Talent Lv. +1, up to a maximum of Lv. 10.



4 Dancer of the Muse

When an ally target with 0 Max Energy actively uses an ability, Mem can also gain 3% Charge, and the multiplier of the True DMG dealt by this target via "Mem's Support" additionally increases by 6%.



5 Seamster of the Ode

Ultimate Lv. +2, up to a maximum of Lv. 15.
Basic ATK Lv. +1, up to a maximum of Lv. 10.
Memosprite Skill Lv. +1, up to a maximum of Lv. 10.



6 Bearer of the Revelation

Ultimate's CRIT Rate is set at 100%.
Hidden Stat: 1.0
 */
export default (e: Eidolon, withContent: boolean): CharacterConditionalsController => {
  const t = TsUtils.wrappedFixedT(withContent).get(null, 'conditionals', 'Characters.TrailblazerRemembrance')
  const tBuff = TsUtils.wrappedFixedT(withContent).get(null, 'conditionals', 'Common.BuffPriority')
  const { basic, skill, ult, talent, memoSkill, memoTalent } = AbilityEidolon.SKILL_TALENT_MEMO_TALENT_3_ULT_BASIC_MEMO_SKILL_5
  const {
    SOURCE_BASIC,
    SOURCE_SKILL,
    SOURCE_ULT,
    SOURCE_TALENT,
    SOURCE_TECHNIQUE,
    SOURCE_TRACE,
    SOURCE_MEMO,
    SOURCE_E1,
    SOURCE_E2,
    SOURCE_E4,
    SOURCE_E6,
  } = Source.character('8008')

  const basicScaling = basic(e, 1.00, 1.10)

  const ultScaling = ult(e, 2.40, 2.64)

  const memoHpScaling = talent(e, 0.80, 0.86)
  const memoHpFlat = talent(e, 640, 688)

  const memoSkillHitScaling = memoSkill(e, 0.36, 0.396)
  const memoSkillFinalScaling = memoSkill(e, 0.90, 0.99)

  const memoTalentCdBuffScaling = memoTalent(e, 0.12, 0.132)
  const memoTalentCdBuffFlat = memoTalent(e, 0.24, 0.264)

  const trueDmgScaling = memoSkill(e, 0.28, 0.30)
  // When the Max Energy of the ally target that has "Mem's Support" exceeds 100, for every 10 excess Energy,
  // additionally increases the multiplier of the True DMG dealt via "Mem's Support" by 2%, up to a max increase of 20%.

  const defaults = {
    buffPriority: BUFF_PRIORITY_SELF,
    memoSkillHits: 4,
    teamCdBuff: true,
    memsSupport: false,
    energyTrueDmgValue: false,
    e1CrBuff: false,
    e4TrueDmgBoost: false,
    e6UltCrBoost: true,
  }

  const teammateDefaults = {
    teamCdBuff: true,
    memCDValue: 2.50,
    memsSupport: true,
    energyTrueDmgValue: true,
    e1CrBuff: true,
    e4TrueDmgBoost: false,
  }

  const content: ContentDefinition<typeof defaults> = {
    buffPriority: {
      id: 'buffPriority',
      formItem: 'select',
      text: tBuff('Text'),
      content: tBuff('Content'),
      options: [
        { display: tBuff('Self'), value: BUFF_PRIORITY_SELF, label: tBuff('Self') },
        { display: tBuff('Memo'), value: BUFF_PRIORITY_MEMO, label: tBuff('Memo') },
      ],
      fullWidth: true,
    },
    memoSkillHits: {
      id: 'memoSkillHits',
      formItem: 'slider',
      text: t('Content.memoSkillHits.text'),
      content: t('Content.memoSkillHits.content',
        { SingleScaling: TsUtils.precisionRound(memoSkillHitScaling * 100), AoeScaling: TsUtils.precisionRound(memoSkillFinalScaling * 100) }),
      min: 0,
      max: 4,
    },
    teamCdBuff: {
      id: 'teamCdBuff',
      formItem: 'switch',
      text: t('Content.teamCdBuff.text'),
      content: t('Content.teamCdBuff.content',
        { ScalingBuff: TsUtils.precisionRound(memoTalentCdBuffScaling * 100), FlatBuff: TsUtils.precisionRound(memoTalentCdBuffFlat * 100) }),
    },
    memsSupport: {
      id: 'memsSupport',
      formItem: 'switch',
      text: t('Content.memsSupport.text'),
      content: t('Content.memsSupport.content', { TrueDmgScaling: TsUtils.precisionRound(trueDmgScaling * 100) }),
    },
    energyTrueDmgValue: {
      id: 'energyTrueDmgValue',
      formItem: 'switch',
      text: t('Content.energyTrueDmgValue.text'),
      content: t('Content.energyTrueDmgValue.content'),
    },
    e1CrBuff: {
      id: 'e1CrBuff',
      formItem: 'switch',
      text: t('Content.e1CrBuff.text'),
      content: t('Content.e1CrBuff.content'),
      disabled: e < 1,
    },
    e4TrueDmgBoost: {
      id: 'e4TrueDmgBoost',
      formItem: 'switch',
      text: t('Content.e4TrueDmgBoost.text'),
      content: t('Content.e4TrueDmgBoost.content'),
      disabled: e < 4,
    },
    e6UltCrBoost: {
      id: 'e6UltCrBoost',
      formItem: 'switch',
      text: t('Content.e6UltCrBoost.text'),
      content: t('Content.e6UltCrBoost.content'),
      disabled: e < 6,
    },
  }

  const teammateContent: ContentDefinition<typeof teammateDefaults> = {
    teamCdBuff: content.teamCdBuff,
    memCDValue: {
      id: 'memCDValue',
      formItem: 'slider',
      text: t('TeammateContent.memCDValue.text'),
      content: t('TeammateContent.memCDValue.content', {
        ScalingBuff: TsUtils.precisionRound(memoTalentCdBuffScaling * 100),
        FlatBuff: TsUtils.precisionRound(memoTalentCdBuffFlat * 100),
      }),
      min: 0,
      max: 4.00,
      percent: true,
    },
    memsSupport: content.memsSupport,
    energyTrueDmgValue: content.energyTrueDmgValue,
    e1CrBuff: content.e1CrBuff,
    e4TrueDmgBoost: content.e4TrueDmgBoost,
  }

  return {
    activeAbilities: [AbilityType.BASIC, AbilityType.ULT, AbilityType.MEMO_SKILL],
    content: () => Object.values(content),
    teammateContent: () => Object.values(teammateContent),
    defaults: () => defaults,
    teammateDefaults: () => teammateDefaults,
    initializeConfigurations: (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) => {
      const r = action.characterConditionals as Conditionals<typeof content>

      x.SUMMONS.set(1, SOURCE_TALENT)
      x.MEMOSPRITE.set(1, SOURCE_TALENT)
      x.MEMO_BUFF_PRIORITY.set(r.buffPriority == BUFF_PRIORITY_SELF ? BUFF_PRIORITY_SELF : BUFF_PRIORITY_MEMO, SOURCE_TALENT)
    },
    precomputeEffects: (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) => {
      const r = action.characterConditionals as Conditionals<typeof content>

      x.BASIC_ATK_SCALING.buff(basicScaling, SOURCE_BASIC)

      x.MEMO_BASE_HP_SCALING.buff(memoHpScaling, SOURCE_MEMO)
      x.MEMO_BASE_HP_FLAT.buff(memoHpFlat, SOURCE_MEMO)
      x.MEMO_BASE_SPD_SCALING.buff(0, SOURCE_MEMO)
      x.MEMO_BASE_SPD_FLAT.buff(130, SOURCE_MEMO)
      x.MEMO_BASE_DEF_SCALING.buff(1, SOURCE_MEMO)
      x.MEMO_BASE_ATK_SCALING.buff(1, SOURCE_MEMO)

      x.m.MEMO_SKILL_ATK_SCALING.buff(r.memoSkillHits * memoSkillHitScaling + memoSkillFinalScaling, SOURCE_MEMO)
      x.m.ULT_ATK_SCALING.buff(ultScaling, SOURCE_MEMO)

      x.m.ULT_CR_BOOST.buff((e >= 6 && r.e6UltCrBoost) ? 1.00 : 0, SOURCE_E6)

      x.BASIC_TOUGHNESS_DMG.buff(10, SOURCE_BASIC)
      x.ULT_TOUGHNESS_DMG.buff(20, SOURCE_ULT)
      x.m.MEMO_SKILL_TOUGHNESS_DMG.buff(15, SOURCE_MEMO)
    },
    precomputeMutualEffects: (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) => {
      const m = action.characterConditionals as Conditionals<typeof teammateContent>

      if (m.memsSupport) {
        const energyTrueDmg = Math.min(0.20, (m.energyTrueDmgValue ? Math.max((context.baseEnergy - 100) / 10, 0) * 2 * 0.01 : 0))
        const trueDmg = trueDmgScaling
          + energyTrueDmg
          + (e >= 4 && m.e4TrueDmgBoost ? 0.06 : 0)

        if (e >= 1) {
          x.CR.buffDual((m.e1CrBuff) ? 0.10 : 0, SOURCE_E1)
          x.TRUE_DMG_MODIFIER.buffDual(trueDmg, SOURCE_MEMO)
        } else {
          x.TRUE_DMG_MODIFIER.buffSingle(trueDmg, SOURCE_MEMO)
        }
      }
    },
    precomputeTeammateEffects: (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) => {
      const t = action.characterConditionals as Conditionals<typeof teammateContent>

      const teamCDBuff = t.teamCdBuff ? memoTalentCdBuffScaling * t.memCDValue + memoTalentCdBuffFlat : 0
      x.CD.buffTeam(teamCDBuff, Source.NONE)
      x.UNCONVERTIBLE_CD_BUFF.buffTeam(teamCDBuff, SOURCE_MEMO)
    },
    finalizeCalculations: (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) => {
    },
    gpuFinalizeCalculations: (action: OptimizerAction, context: OptimizerContext) => '',
    dynamicConditionals: [
      {
        id: 'TrailblazerRemembranceCdConditional',
        type: ConditionalType.ABILITY,
        activation: ConditionalActivation.CONTINUOUS,
        dependsOn: [Stats.CD],
        chainsTo: [Stats.CD],
        condition: function (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) {
          return true
        },
        effect: function (x: ComputedStatsArray, action: OptimizerAction, context: OptimizerContext) {
          const r = action.characterConditionals as Conditionals<typeof content>
          if (!r.teamCdBuff) {
            return
          }
          if (x.a[Key.MEMOSPRITE]) {
            return this.effect(x.m, action, context)
          }

          const stateValue = action.conditionalState[this.id] || 0
          const convertibleCdValue = x.a[Key.CD] - x.a[Key.UNCONVERTIBLE_CD_BUFF]

          const buffCD = memoTalentCdBuffScaling * convertibleCdValue + memoTalentCdBuffFlat
          const stateBuffCD = memoTalentCdBuffScaling * stateValue + memoTalentCdBuffFlat

          action.conditionalState[this.id] = convertibleCdValue

          const finalBuffCd = Math.max(0, buffCD - (stateValue ? stateBuffCD : 0))
          x.UNCONVERTIBLE_CD_BUFF.buff(finalBuffCd, SOURCE_MEMO)

          x.CD.buffDynamic(finalBuffCd, SOURCE_MEMO, action, context)
          x.summoner().CD.buffDynamic(finalBuffCd, SOURCE_MEMO, action, context)
        },
        gpu: function (action: OptimizerAction, context: OptimizerContext) {
          const r = action.characterConditionals as Conditionals<typeof content>

          return conditionalWgslWrapper(this, `
if (${wgslFalse(r.teamCdBuff)}) {
  return;
}

let stateValue: f32 = (*p_state).TrailblazerRemembranceCdConditional;
let convertibleCdValue: f32 = (*p_m).CD - (*p_m).UNCONVERTIBLE_CD_BUFF;

var buffCD: f32 = ${memoTalentCdBuffScaling} * convertibleCdValue + ${memoTalentCdBuffFlat};
var stateBuffCD: f32 = ${memoTalentCdBuffScaling} * stateValue + ${memoTalentCdBuffFlat};

(*p_state).TrailblazerRemembranceCdConditional = (*p_m).CD;

let finalBuffCd = max(0.0, buffCD - select(0.0, stateBuffCD, stateValue > 0.0));
(*p_m).UNCONVERTIBLE_CD_BUFF += finalBuffCd;

(*p_m).CD += finalBuffCd;
(*p_x).CD += finalBuffCd;
`)
        },
      },
    ],
  }
}
